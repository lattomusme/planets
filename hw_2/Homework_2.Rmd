---
title: "Intermediate Homework"
author: "Morgan Lattomus"
date: "1/18/2022"
output:
  word_document: default
  html_document: default
  pdf_document: default
---
```{r}
data(iris)
head(iris)
```
```{r}
sp_ids <- unique(iris$species)
#this is the same thing as setting the null 
output <- matrix(0, nrow=length(sp_ids), ncol=ncol(iris)-1) 
#the ncol(iris)-1 makes the last column go away
rownames(output) <- sp_ids 
#classifies all the rows as sp_ids
colnames(output) <- names(iris[ ,-ncol(iris)])
# I don't quite know what this one does...maybe assigns the column names to be the negative or inverse from of the original point?

?seq_along()
#used to generate regular sequences quicker than just seg()
seq_along(sp_ids)
#creates an integer sequence to be used in the definition of the i variable

for(i in seq_along(sp_ids)) {
    iris_sp <- subset(iris, subset <- Species == sp_ids[i], select=-Species)
}
subset(iris, subset=Species == sp_ids[i], select=-Species)
?subset()
#creates a subset in reference to the rows, could do columns if you called them out by name
```

```{r}
for(i in seq_along(sp_ids)) {
    iris_sp <- subset(iris, subset <- Species == sp_ids[i], select=-Species)
    for(j in 1:(ncol(iris_sp))) { #defining the columns and assigning a value to organize using
        x <- 0
        y <- 0
        if (nrow(iris_sp) > 0) {
            for(k in 1:nrow(iris_sp)) { #defining the rows the same way but using functions
                x <- x + iris_sp[k, j]
                y <- y + 1
            }
            output[i, j] <- x / y 
        }
    }
}
output
```
```{r}
#all together to adjust the actual table now!
sp_ids <- unique(iris$Species)

output <- matrix(0, nrow=length(sp_ids), ncol=ncol(iris)-1)
rownames(output) <- sp_ids
colnames(output) <- names(iris[ , -ncol(iris)])

for(i in seq_along(sp_ids)) {
    iris_sp <- subset(iris, subset=Species == sp_ids[i], select=-Species)
    for(j in 1:(ncol(iris_sp))) {
        x <- 0
        y <- 0
        if (nrow(iris_sp) > 0) {
            for(k in 1:nrow(iris_sp)) {
                x <- x + iris_sp[k, j]
                y <- y + 1
            }
            output[i, j] <- x / y 
        }
    }
}
output
```

#Iris loops
1. Describe the values stored in the object output. In other words what did the loops create?

The loops created an average of the data points per species and adding 1 to y - representing n in this data set - until we run out of data to compute.

```{r}
summary('output')
```

2. Describe using pseudo-code how output was calculated, for example,

Loop using a sequence made of sp_ids
  Take subset of 'Species', assigned to sp_ids, selected not Species
  Loop from 1 to the number of columns in iris_sp
  Assign x and y to 0
    If x is greater than 0...
      Loop from 1 to the number of rows in iris_sp
      Assign x the value of x + the loop from 1:number of rows and the loop from 1:number of columns
      Assign y the value of y + 1
      Define the output as the sequence generated by sp_ids and the loop from 1:number of columns
  
3. The variables in the loop were named so as to be vague. How can the objects 'output', 'x', and 'y' be renamed such that it is clearer what is occurring in the loop?

'X' can be renamed to 'mm_value' to be the measurement recorded for each of the 'y', or rather the 'mm_type' (type of measurement). 'Output' could be renamed to "mm_sp', or the measurements per species as this is the command to make the table look the way that it does in the output, with the type of measurement on the x axis and the species on the y.

4. It is possible to accomplish the same task using fewer lines of code? Please suggest one other way to calculate output that decreases the number of loops by 1.

```{r}
sp_ids <- unique(iris$Species)
output <- matrix(0, nrow=length(sp_ids), ncol=ncol(iris)-1)
rownames(output) <- sp_ids
colnames(output) <- names(iris[ , -ncol(iris)])

for(i in seq_along(sp_ids)) {
    iris_sp <- subset(iris, subset=Species == sp_ids[i], select=-Species)
    
    for(j in 1:(ncol(iris_sp))) {
        output[i,j] <- mean(iris_sp[ ,j])
    }
}
output
```

Sum of a sequence
5. You have a vector x with the numbers 1:10. Write a for loop that will produce a vector y that contains the sum of x up to that index of x. So for example the elements of x are 1, 2, 3, and so on and the elements of y would be 1, 3, 6, and so on.

```{r}
x <- 1:10
y <- 0

for(i in 1:10) {
  y[i] = sum(x[1:i])
}
y
```

6. Modify your for loop so that if the sum is greater than 10 the value of y is set to NA

```{r}
x <- 1:10
y <- 0
  
  
for (i in 1:10) {
  y[i] = sum(x[1:i])
  if (y[i] <= 10) {
    print(y)
  } else if (y[i] > 10) {
    y = NA
    print(y)
  }
}
```

7. Place your for loop into a function that accepts as its argument any vector of arbitrary length and it will return y.

```{r}
my_func <- function(x){

  y <- 0
  
    for (i in x) {
     y[i] = sum(x[1:i])
      if (y[i] <= 10) {
        print(y)
      } else if (y[i] > 10) {
        y = NA
       print(y)
      }
    }
  } 

my_func(c(1:67))
```
